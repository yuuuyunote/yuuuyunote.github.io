<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Quick Marker Pro - iPad Optimized</title>
  <style>
    :root {
      --bg-primary: #ffffff; --bg-secondary: #f5f5f5; --bg-toolbar: #ffffff;
      --text-primary: #333333; --text-secondary: #666666; --border-color: #e0e0e0;
      --accent-color: #5e89e6; --shadow: 0 2px 8px rgba(0,0,0,0.1); --canvas-bg: #f0f0f0;
    }
    [data-theme="dark"] {
      --bg-primary: #1e1e1e; --bg-secondary: #2d2d2d; --bg-toolbar: #252525;
      --text-primary: #e0e0e0; --text-secondary: #a0a0a0; --border-color: #404040;
      --accent-color: #7aa2f7; --shadow: 0 2px 8px rgba(0,0,0,0.3); --canvas-bg: #2a2a2a;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: sans-serif; background: var(--bg-primary); color: var(--text-primary); overflow-x: hidden; }
    .container { max-width: 1200px; margin: 0 auto; padding: 10px; }
    .toolbar { display: flex; flex-wrap: wrap; gap: 8px; padding: 12px; background: var(--bg-toolbar); border-radius: 12px; box-shadow: var(--shadow); margin-bottom: 12px; }
    .tool-group { display: flex; gap: 4px; padding-right: 8px; border-right: 1px solid var(--border-color); align-items: center; }
    .tool-group:last-child { border-right: none; }
    .tool-group-label { font-size: 0.7rem; color: var(--text-secondary); margin-right: 4px; }
    .tool-btn { background: var(--bg-secondary); border: 2px solid transparent; border-radius: 6px; padding: 8px 12px; cursor: pointer; font-size: 0.85rem; color: var(--text-primary); }
    .tool-btn.active { border-color: var(--accent-color); background: var(--accent-color); color: white; }
    .color-picker { width: 36px; height: 36px; border: 1px solid var(--border-color); border-radius: 6px; cursor: pointer; }
    .canvas-container { background: var(--canvas-bg); border-radius: 12px; padding: 20px; min-height: 400px; display: flex; justify-content: center; overflow: auto; position: relative; }
    #canvas { touch-action: none; box-shadow: 0 0 20px rgba(0,0,0,0.1); }
    #fileInput { display: none; }
    .bottom-bar { margin-top: 12px; display: flex; justify-content: space-between; align-items: center; }
    .status-bar { font-size: 0.8rem; color: var(--text-secondary); }
  </style>
</head>
<body>

<div class="container">
  <div class="toolbar">
    <div class="tool-group">
      <button class="tool-btn" onclick="pasteFromClipboard()">ğŸ“‹ è²¼ä»˜</button>
      <button class="tool-btn" onclick="document.getElementById('fileInput').click()">ğŸ“‚ é–‹ã</button>
      <input type="file" id="fileInput" accept="image/*" onchange="loadFromFile(event)">
    </div>
    <div class="tool-group">
      <button class="tool-btn" onclick="undo()">â†©ï¸</button>
      <button class="tool-btn" data-tool="select" onclick="setTool('select')">ğŸ¯</button>
      <button class="tool-btn" data-tool="arrow" onclick="setTool('arrow')">â¡ï¸</button>
      <button class="tool-btn" data-tool="rect" onclick="setTool('rect')">â¬œ</button>
      <button class="tool-btn" data-tool="blur" onclick="setTool('blur')">ğŸŒ«ï¸</button>
      <button class="tool-btn" data-tool="number" onclick="setTool('number')">ğŸ”¢</button>
    </div>
    <div class="tool-group">
      <span class="tool-group-label">å¤ªã•</span>
      <button class="tool-btn small" data-stroke="3" onclick="setStroke(3)">ç´°</button>
      <button class="tool-btn small" data-stroke="7" onclick="setStroke(7)">ä¸­</button>
      <button class="tool-btn small" data-stroke="12" onclick="setStroke(12)">å¤ª</button>
    </div>
    <div class="tool-group">
      <span class="tool-group-label">è§’ä¸¸</span>
      <button class="tool-btn small" data-radius="0" onclick="setCornerRadius(0)">ç„¡</button>
      <button class="tool-btn small" data-radius="20" onclick="setCornerRadius(20)">S</button>
      <button class="tool-btn small" data-radius="50" onclick="setCornerRadius(50)">M</button>
    </div>
    <div class="tool-group">
      <span class="tool-group-label">ãƒ•ãƒ</span>
      <button class="tool-btn small" data-border="0" onclick="setBorderWidth(0)">ç„¡</button>
      <button class="tool-btn small" data-border="10" onclick="setBorderWidth(10)">ç´°</button>
      <button class="tool-btn small" data-border="25" onclick="setBorderWidth(25)">å¤ª</button>
      <input type="color" class="color-picker" id="borderColorPicker" value="#ffffff" onchange="render()">
    </div>
    <div class="tool-group">
      <input type="color" class="color-picker" id="colorPicker" value="#e53935">
    </div>
    <button class="tool-btn" style="background:#dc3545;color:white;" onclick="deleteSelected()">ğŸ—‘ï¸ å‰Šé™¤</button>
  </div>

  <div class="canvas-container">
    <canvas id="canvas" style="display:none;"></canvas>
  </div>

  <div class="bottom-bar">
    <div class="status-bar" id="statusBar">ç”»åƒã‚’é¸æŠã—ã¦ãã ã•ã„</div>
    <button class="tool-btn" style="background:#28a745;color:white;" onclick="saveImage()">ğŸ’¾ ä¿å­˜</button>
  </div>
</div>

<script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const statusBar = document.getElementById('statusBar');
  const colorPicker = document.getElementById('colorPicker');
  const borderColorPicker = document.getElementById('borderColorPicker');

  let baseImage = null;
  let objects = [];
  let history = [];
  let currentTool = 'arrow';
  let isDrawing = false, isDragging = false;
  let startX, startY, dragOffsetX, dragOffsetY;
  let strokeWidth = 7;
  let cornerRadius = 0, borderWidth = 0;
  let selectedIndex = -1;

  function setTool(tool) {
    currentTool = tool;
    document.querySelectorAll('[data-tool]').forEach(b => b.classList.toggle('active', b.dataset.tool === tool));
    render();
  }
  function setStroke(w) {
    strokeWidth = w;
    document.querySelectorAll('[data-stroke]').forEach(b => b.classList.toggle('active', parseInt(b.dataset.stroke) === w));
  }
  function setCornerRadius(r) { cornerRadius = r; render(); }
  function setBorderWidth(w) { borderWidth = w; resizeCanvas(); render(); }
  
  setTool('arrow'); setStroke(7);

  function resizeCanvas() {
    if (!baseImage) return;
    canvas.width = baseImage.width + (borderWidth * 2);
    canvas.height = baseImage.height + (borderWidth * 2);
  }

  function loadFromFile(e) {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (f) => {
        const img = new Image();
        img.onload = () => {
          baseImage = img;
          resizeCanvas();
          canvas.style.display = 'block';
          objects = []; saveToHistory(); render();
        };
        img.src = f.target.result;
      };
      reader.readAsDataURL(file);
    }
  }

  async function pasteFromClipboard() {
    try {
      const items = await navigator.clipboard.read();
      for (const item of items) {
        for (const type of item.types) {
          if (type.startsWith('image/')) {
            const blob = await item.getType(type);
            const img = new Image();
            img.onload = () => {
              baseImage = img; resizeCanvas();
              canvas.style.display = 'block';
              objects = []; saveToHistory(); render();
            };
            img.src = URL.createObjectURL(blob);
          }
        }
      }
    } catch (e) { alert("ãƒ–ãƒ©ã‚¦ã‚¶ã®è²¼ã‚Šä»˜ã‘è¨±å¯ãŒå¿…è¦ã§ã™"); }
  }

  function getCoords(e) {
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches ? e.touches[0] : e;
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    return {
      x: (touch.clientX - rect.left) * scaleX - borderWidth,
      y: (touch.clientY - rect.top) * scaleY - borderWidth
    };
  }

  function handleStart(e) {
    if (!baseImage) return;
    const {x, y} = getCoords(e);
    startX = x; startY = y;

    if (currentTool === 'select') {
      selectedIndex = hitTest(x, y);
      if (selectedIndex >= 0) {
        isDragging = true;
        const obj = objects[selectedIndex];
        dragOffsetX = x - (obj.x || obj.x1 || 0);
        dragOffsetY = y - (obj.y || obj.y1 || 0);
      }
    } else if (currentTool === 'number') {
      const nums = objects.filter(o => o.type === 'number').map(o => o.num);
      const next = nums.length > 0 ? Math.max(...nums) + 1 : 1;
      objects.push({type: 'number', x, y, num: next, color: colorPicker.value});
      saveToHistory();
    } else {
      isDrawing = true;
    }
    render();
  }

  function handleMove(e) {
    if (!isDrawing && !isDragging) return;
    if (e.cancelable) e.preventDefault();
    const {x, y} = getCoords(e);

    if (isDragging) {
      const obj = objects[selectedIndex];
      if (obj.type === 'arrow') {
        const dx = x - startX; const dy = y - startY;
        obj.x1 += dx; obj.y1 += dy; obj.x2 += dx; obj.y2 += dy;
        startX = x; startY = y;
      } else {
        obj.x = x - dragOffsetX; obj.y = y - dragOffsetY;
      }
    }
    render();
    if (isDrawing) {
      ctx.save(); ctx.translate(borderWidth, borderWidth);
      if (currentTool === 'arrow') drawArrow({x1: startX, y1: startY, x2: x, y2: y, color: colorPicker.value, stroke: strokeWidth});
      if (currentTool === 'rect') drawRect({x: startX, y: startY, w: x - startX, h: y - startY, color: colorPicker.value, stroke: strokeWidth});
      if (currentTool === 'blur') { ctx.setLineDash([5,5]); ctx.strokeRect(startX, startY, x-startX, y-startY); }
      ctx.restore();
    }
  }

  function handleEnd(e) {
    if (isDrawing) {
      const touch = e.changedTouches ? e.changedTouches[0] : e;
      const {x, y} = getCoords({touches: [touch], clientX: touch.clientX, clientY: touch.clientY});
      if (Math.abs(x - startX) > 5) {
        if (currentTool === 'arrow') objects.push({type:'arrow', x1:startX, y1:startY, x2:x, y2:y, color:colorPicker.value, stroke:strokeWidth});
        if (currentTool === 'rect') objects.push({type:'rect', x:startX, y:startY, w:x-startX, h:y-startY, color:colorPicker.value, stroke:strokeWidth});
        if (currentTool === 'blur') objects.push({type:'blur', x:startX, y:startY, w:x-startX, h:y-startY});
        saveToHistory();
      }
    }
    if (isDragging) saveToHistory();
    isDrawing = false; isDragging = false; render();
  }

  canvas.addEventListener('touchstart', handleStart, {passive: false});
  window.addEventListener('touchmove', handleMove, {passive: false});
  window.addEventListener('touchend', handleEnd);
  canvas.addEventListener('mousedown', handleStart);
  window.addEventListener('mousemove', handleMove);
  window.addEventListener('mouseup', handleEnd);

  function render() {
    if (!baseImage) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // ãƒ•ãƒã®æç”»
    ctx.fillStyle = borderColorPicker.value;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // è§’ä¸¸ã®é©ç”¨
    ctx.save();
    if (cornerRadius > 0) {
      ctx.beginPath();
      ctx.roundRect(borderWidth, borderWidth, baseImage.width, baseImage.height, cornerRadius);
      ctx.clip();
    }
    ctx.drawImage(baseImage, borderWidth, borderWidth);

    ctx.translate(borderWidth, borderWidth);
    objects.forEach((obj, i) => {
      if (obj.type === 'blur') drawBlur(obj);
      if (obj.type === 'arrow') drawArrow(obj);
      if (obj.type === 'rect') drawRect(obj);
      if (obj.type === 'number') drawNumber(obj);
      if (i === selectedIndex) {
        ctx.setLineDash([5,5]); ctx.strokeStyle = '#00aaff'; ctx.strokeRect((obj.x||obj.x1)-10, (obj.y||obj.y1)-10, (obj.w||(obj.x2-obj.x1))+20, (obj.h||(obj.y2-obj.y1))+20);
      }
    });
    ctx.restore();
  }

  function drawArrow(obj) {
    const head = obj.stroke * 3;
    const angle = Math.atan2(obj.y2 - obj.y1, obj.x2 - obj.x1);
    ctx.strokeStyle = obj.color; ctx.fillStyle = obj.color; ctx.lineWidth = obj.stroke; ctx.lineCap = 'round';
    ctx.beginPath(); ctx.moveTo(obj.x1, obj.y1); ctx.lineTo(obj.x2, obj.y2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(obj.x2, obj.y2);
    ctx.lineTo(obj.x2 - head * Math.cos(angle - Math.PI/6), obj.y2 - head * Math.sin(angle - Math.PI/6));
    ctx.lineTo(obj.x2 - head * Math.cos(angle + Math.PI/6), obj.y2 - head * Math.sin(angle + Math.PI/6));
    ctx.fill();
  }

  function drawRect(obj) {
    ctx.strokeStyle = obj.color; ctx.lineWidth = obj.stroke;
    ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
  }

  function drawBlur(obj) {
    ctx.save();
    ctx.beginPath(); ctx.rect(obj.x, obj.y, obj.w, obj.h); ctx.clip();
    ctx.filter = 'blur(15px)';
    ctx.drawImage(canvas, -borderWidth, -borderWidth);
    ctx.restore();
  }

  function drawNumber(obj) {
    ctx.fillStyle = obj.color; ctx.beginPath(); ctx.arc(obj.x, obj.y, 20, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = 'white'; ctx.font = 'bold 20px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(obj.num, obj.x, obj.y + 1);
  }

  function hitTest(x, y) {
    return objects.findIndex(obj => {
      const b = {x: obj.x||obj.x1, y: obj.y||obj.y1, w: obj.w||(obj.x2-obj.x1), h: obj.h||(obj.y2-obj.y1)};
      return x >= b.x-10 && x <= b.x+b.w+10 && y >= b.y-10 && y <= b.y+b.h+10;
    });
  }

  function saveToHistory() { history.push(JSON.stringify(objects)); if(history.length > 30) history.shift(); }
  function undo() { if(history.length > 1) { history.pop(); objects = JSON.parse(history[history.length-1]); render(); } }
  function deleteSelected() { if(selectedIndex >= 0) { objects.splice(selectedIndex, 1); selectedIndex = -1; saveToHistory(); render(); } }
  
  function saveImage() {
    const link = document.createElement('a');
    link.download = 'marker.png';
    link.href = canvas.toDataURL();
    link.click();
  }
</script>
</body>
</html>
